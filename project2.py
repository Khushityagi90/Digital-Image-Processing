# -*- coding: utf-8 -*-
"""Project2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WO0avwJzBb9zl6nQsLPY7Ds3exQMcRqL

# **DIP Project 2**
"""

import cv2
from google.colab.patches import cv2_imshow
import numpy as np
from skimage.util import random_noise
from skimage.restoration import denoise_wavelet
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

from IPython.display import Image
Image('/content/drive/MyDrive/PHOTO_DIP.jpg')

img = cv2.imread('/content/drive/MyDrive/PHOTO_DIP.jpg')

if img is not None:
    print("Original Image")
    img = cv2.resize(img, (516, 516))
    cv2_imshow(img)
else:
    print("Image not found or could not be read.")

"""### Originial Image

### Converting To Gray Scale Image
"""

gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
print("Gray Scale Image:")
cv2_imshow(gray_image)

"""### Adding Salt and Pepper Noise"""

noisy_image = random_noise(gray_image, mode='s&p', amount=0.3)
noisy_image = np.array(255 * noisy_image, dtype='uint8')

    # Display the noisy image
print("Image with Salt and Pepper Noise:")
cv2_imshow(noisy_image)

"""### Remove Salt and Noise Using Adaptive Median Filter"""

def adaptive_median_filter(img, max_kernel_size=7):
    filtered_img = img.copy()
    rows, cols = img.shape
    for i in range(rows):
        for j in range(cols):
            k = 3
            while k <= max_kernel_size:
                rmin = max(i - k//2, 0)
                rmax = min(i + k//2 + 1, rows)
                cmin = max(j - k//2, 0)
                cmax = min(j + k//2 + 1, cols)
                window = img[rmin:rmax, cmin:cmax]
                Zmin = window.min()
                Zmax = window.max()
                Zmed = np.median(window)
                A1 = Zmed - Zmin
                A2 = Zmed - Zmax
                if A1 > 0 and A2 < 0:
                    B1 = img[i, j] - Zmin
                    B2 = img[i, j] - Zmax
                    if B1 > 0 and B2 < 0:
                        filtered_img[i, j] = img[i, j]
                    else:
                        filtered_img[i, j] = Zmed
                    break
                else:
                    k += 2
                    if k > max_kernel_size:
                        filtered_img[i, j] = Zmed
                        break
    return filtered_img

filtered_image = adaptive_median_filter(noisy_image)
print("Image after Adaptive Median Filter:")
cv2_imshow(filtered_image)

"""### Canny Edge Detection"""

edges = cv2.Canny(filtered_image,100,200)
print("Canny Edge Detection:")
cv2_imshow(edges)

"""### Otsu's Thresholding"""

ret, thresholded_image = cv2.threshold(filtered_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

print("Thresholding value:", ret)
print("Binary Image (after Otsu's thresholding):")
cv2_imshow(thresholded_image)